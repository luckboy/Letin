/****************************************************************************
 *   Copyright (C) 2014 ≈Åukasz Szpakowski.                                  *
 *                                                                          *
 *   This software is licensed under the GNU Lesser General Public          *
 *   License v3 or later. See the LICENSE file and the GPL file for         *
 *   the full licensing terms.                                              *
 ****************************************************************************/
%{
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <sstream>
#include <string>
#include "driver.hpp"
#include "lexer.hpp"

#define YY_USER_ACTION          loc->columns();
%}

%option c++
%option yyclass="letin::comp::impl::Lexer"
%option prefix="LetinCompImpl"

%x IN_COMMENT
%x IN_CHAR
%x IN_STRING
%%

%{
  loc->step();
%}

"//"[^\n]*

"/*"                            { BEGIN(IN_COMMENT); }
<IN_COMMENT>"*/"                { loc->step(); BEGIN(INITIAL); }
<IN_COMMENT>[^\n]
<IN_COMMENT>"\n"                { loc->lines(); }

"\'"                            { BEGIN(IN_CHAR); buffer = std::string(); }
"\""                            { BEGIN(IN_STRING); buffer = std::string(); }
<IN_CHAR>"\'"                   {
  BEGIN(INITIAL);
  lval->i = buffer[0];
  return token::INT;
}
<IN_CHAR>[^\\\'\n]              { buffer += yytext[0]; }
<IN_STRING>"\""                 {
  BEGIN(INITIAL);
  lval->string = new std::string(buffer);
  return token::STRING;
}
<IN_STRING>[^\\\"\n]            { buffer += yytext[0]; }
<IN_CHAR,IN_STRING>"\\a"        { buffer += '\a'; }
<IN_CHAR,IN_STRING>"\\b"        { buffer += '\b'; }
<IN_CHAR,IN_STRING>"\\t"        { buffer += '\t'; }
<IN_CHAR,IN_STRING>"\\n"        { buffer += '\n'; }
<IN_CHAR,IN_STRING>"\\v"        { buffer += '\v'; }
<IN_CHAR,IN_STRING>"\\f"        { buffer += '\f'; }
<IN_CHAR,IN_STRING>"\\r"        { buffer += '\r'; }
<IN_CHAR,IN_STRING>"\\"[0-7]{1,3} {
  std::istringstream iss(yytext + 1);
  unsigned i;
  iss >> i;
  buffer += static_cast<char>(i);
}
<IN_CHAR,IN_STRING>"\\".        { buffer += yytext[1]; }

".entry"                        { return token::ENTRY; }

"a"[0-9]+                       {
  std::istringstream iss(yytext + 1);
  iss >> (lval->u32);
  return token::A;
}

"lv"[0-9]+                      {
  std::istringstream iss(yytext + 1);
  iss >> (lval->u32);
  return token::LV;
}

[+\-]?[1-9][0-9]+               {
  const char *str = (yytext[0] == '+' || yytext[0] == '-') ? yytext + 1 : yytext;
  std::istringstream iss(str);
  iss >> (lval->i);
  if(yytext[0] == '-') lval->i = -lval->i;
  return token::INT;
}

[+\-]?"0"[0-7]+                 {
  const char *str = (yytext[0] == '+' || yytext[0] == '-') ? yytext + 1 : yytext;
  std::istringstream iss(str + 1);
  iss >> std::oct >> (lval->i);
  if(yytext[0] == '-') lval->i = -lval->i;
  return token::INT;
}

[+\-]?"0"[Xx][0-9A-Fa-f]+       {
  const char *str = (yytext[0] == '+' || yytext[0] == '-') ? yytext + 1 : yytext;
  std::istringstream iss(str + 2);
  iss >> std::hex >> (lval->i);
  if(yytext[0] == '-') lval->i = -lval->i;
  return token::INT;
}

[+\-]?[0-9]+"."[0-9]*([Ee][+\-]?[0-9]+)? {
  const char *str = (yytext[0] == '+' || yytext[0] == '-') ? yytext + 1 : yytext;
  std::istringstream iss(str);
  iss >> (lval->f);
  if(yytext[0] == '-') lval->f = -lval->f;
  return token::FLOAT;
}

[A-Za-z][A-Za-z0-9]*            {
  lval->string = new std::string(yytext);
  return token::NAME;
}

[_A-Za-z\$][_A-Za-z0-9\.\$]*    {
  lval->string = new std::string(yytext);
  return token::IDENT;
}

"`"[^\`\n]+"`"                  {
  lval->string = new std::string(yytext + 1, std::strlen(yytext) - 2);
  return token::IDENT;
}

"("|")"|"["|"]"|","|"="|"&"     { return yytext[0]; }

[ \t\r]                         { loc->step(); }

"\n"+                           { loc->lines(); return '\n'; }

%%

int LetinCompImplFlexLexer::yywrap() { return 1; }

namespace letin
{
  namespace comp
  {
    namespace impl
    {
      Lexer::~Lexer() {}
    }
  }
}
