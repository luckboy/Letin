/****************************************************************************
 *   Copyright (C) 2014 ≈Åukasz Szpakowski.                                  *
 *                                                                          *
 *   This software is licensed under the GNU Lesser General Public          *
 *   License v3 or later. See the LICENSE file and the GPL file for         *
 *   the full licensing terms.                                              *
 ****************************************************************************/
%skeleton "lalr1.cc"
%defines
%define api.namespace { letin::comp::impl }
%define parser_class_name { Parser }

%code requires {
#include <cstddef>
#include <cstdint>
#include <iostream>
#include <list>
#include <memory>
#include <letin/comp.hpp>
#include "driver.hpp"
#include "parse_tree.hpp"

#define P(loc)          loc_to_pos(driver.source(), loc)

  namespace letin
  {
    namespace comp
    {
      namespace impl
      {
        class Lexer;
      }
    }
  }
}

%param { Driver &driver }
%param { Lexer &lexer }

%code {
  static int yylex(letin::comp::impl::Parser::semantic_type *lval, letin::comp::impl::Parser::location_type *loc, letin::comp::impl::Driver &driver, letin::comp::impl::Lexer &lexer); 

  static letin::comp::Position loc_to_pos(const letin::comp::Source &source, const letin::comp::impl::Parser::location_type &loc);
}

%locations
%initial-action
{
  @$.begin.filename = @$.end.filename = &(driver.file_name());
}

%union {
  std::int64_t i;
  double f;
  std::string *string;
  std::uint32_t u32;
  ArgumentValue *arg_value;
  Value *value;
  Object *object;
  Argument *arg;
  Operation *op;
  Label *label;
  Instruction *instr;
  FunctionLine *fun_line;
  std::shared_ptr<Definition> *def;
  std::shared_ptr<std::list<Value>> *values;
  std::shared_ptr<std::list<FunctionLine>> *fun_lines;  
}

%token                  END             0  
%token <i>              INT
%token <f>              FLOAT
%token <string>         STRING
%token <string>         NAME
%token <string>         IDENT
%token <u32>            LV
%token <u32>            A
%token                  ENTRY
%type <string>          ident
%type <arg_value>       arg_value
%type <value>           value
%type <object>          object
%type <arg>             arg
%type <op>              op
%type <label>           label
%type <instr>           instr
%type <fun_line>        fun_line
%type <def>             fun_def
%type <def>             var_def
%type <def>             entry_def
%type <values>          values
%type <fun_lines>       fun_lines

%destructor { delete $$; }      <string>
%destructor { delete $$; }      <arg_value>
%destructor { delete $$; }      <value>
%destructor { delete $$; }      <object>
%destructor { delete $$; }      <arg>
%destructor { delete $$; }      <op>
%destructor { delete $$; }      <label>
%destructor { delete $$; }      <instr>
%destructor { delete $$; }      <fun_line>
%destructor { delete $$; }      <def>
%destructor { delete $$; }      <values>
%destructor { delete $$; }      <fun_lines>

%%

input:
|               input '\n' def
|               input '\n'
;

def:            fun_def                         { driver.parse_tree().add_def(*$1); }
|               var_def                         { driver.parse_tree().add_def(*$1); }
|               entry_def                       { driver.parse_tree().add_def(*$1); }
;

fun_def:        ident '(' A ')' '=' onl '{' '\n' fun_lines '\n' '}' {
  $$ = new std::shared_ptr<Definition>(new FunctionDefinition(*$1, Function($3, *$9, P(@1)), P(@1)));
}
;

fun_lines:      fun_lines '\n' fun_line         { (*$1)->push_back(*$3); $$ = $1; }
|               fun_line                        {
  $$ = new std::shared_ptr<std::list<FunctionLine>>(new std::list<FunctionLine> { *$1 });
}
;

fun_line:       label ':' instr                 { $$ = new FunctionLine(*$1, *$3); }
|               label ':'                       { $$ = new FunctionLine(*$1); }
|               instr                           { $$ = new FunctionLine(*$1); }
|                                               { $$ = new FunctionLine(); }
;

label:          ident                           { $$ = new Label(*$1, P(@1)); }
;

instr:          NAME op arg ',' arg             { $$ = new Instruction(*$1, *$2, *$3, *$5, P(@1)); }
|               NAME op arg                     { $$ = new Instruction(*$1, *$2, *$3, P(@1)); }
|               NAME op '(' arg ',' arg ')'     { $$ = new Instruction(*$1, *$2, *$4, *$6, P(@1)); }
|               NAME op '(' arg ')'             { $$ = new Instruction(*$1, *$2, *$4, P(@1)); }
|               NAME op '(' ')'                 { $$ = new Instruction(*$1, *$2, P(@1)); }
|               NAME arg ',' arg                { $$ = new Instruction(*$1, *$2, *$4, P(@1)); }
|               NAME arg                        { $$ = new Instruction(*$1, *$2, P(@1)); }
|               NAME                            { $$ = new Instruction(*$1, P(@1)); }
;

op:             NAME                            { $$ = new Operation(*$1, P(@1)); }
;

arg:            arg_value                       { $$ = new Argument(*$1, P(@1)); }
|               LV                              { $$ = new Argument(LVAR, $1, P(@1)); }
|               A                               { $$ = new Argument(ARG, $1, P(@1)); }
|               ident                           { $$ = new Argument(*$1, P(@1)); }
;

arg_value:      INT                             { $$ = new ArgumentValue($1); }
|               FLOAT                           { $$ = new ArgumentValue($1); }
|               '&' ident                       { $$ = new ArgumentValue(*$2); }
;

var_def:        ident '=' onl value             {
  $$ = new std::shared_ptr<Definition>(new VariableDefinition(*$1, *$4, P(@1)));
}
;

value:          INT                             { $$ = new Value($1, P(@1)); }
|               FLOAT                           { $$ = new Value($1, P(@1)); }
|               object                          { $$ = new Value(new Object(*$1), P(@1)); }
;

object:         STRING                          { $$ = new Object(*$1, P(@1)); }
|               NAME '[' onl values onl ']'     { $$ = new Object(*$1, *$4, P(@1)); }
|               '[' onl values onl ']'          { $$ = new Object("iarray64", *$3, P(@1)); }
|               '(' onl values onl ')'          { $$ = new Object("tuple", *$3, P(@1)); }
;

values:         values onl ',' onl value        { (*$1)->push_back(*$5); $$ = $1; }
|               value                           {
  $$ = new std::shared_ptr<std::list<Value>>(new std::list<Value> { *$1 });
}
|                                               {
  $$ = new std::shared_ptr<std::list<Value>>(new std::list<Value>());
}
;

entry_def:      ENTRY ident                     {
  $$ = new std::shared_ptr<Definition>(new EntryDefinition(*$2, P(@1)));
}
;

onl:
|               '\n'
;

ident:          NAME
|               IDENT
;

%%

#include "lexer.hpp"

namespace letin
{
  namespace comp
  {
    namespace impl
    {
      void Parser::error(const location &loc, const std::string &msg)
      { driver.add_error(Error(P(loc), msg)); }
    }
  }
}

static letin::comp::Position loc_to_pos(const letin::comp::Source &source, const letin::comp::impl::Parser::location_type &loc)
{ return letin::comp::Position(source, loc.begin.line, loc.begin.column); }

static int yylex(letin::comp::impl::Parser::semantic_type *lval, letin::comp::impl::Parser::location_type *loc, letin::comp::impl::Driver &driver, letin::comp::impl::Lexer &lexer)
{ return lexer.lex(lval, loc); }
